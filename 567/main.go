package main

import "fmt"

func main() {
	fmt.Println(checkInclusion("abc", "bbbca"))
}

func checkInclusion(s1 string, s2 string) bool {
	// Проверяем что подстрока меньше самой строки
	if len(s1) > len(s2) {
		return false
	}
	// в условии у нас используются только англ буквы, поэтому мы будем решать через срез из 26 символов
	// Определяем срезы как для подстроки(s1Count), так и для подсчета в основной строке (s2Count)
	s1Count := make([]int, 26)
	s2Count := make([]int, 26)

	// Проходим циклом по первой (s1) и по второй строке (s2)
	// сразу добавляем элементы в наш массив, ограничение у нас по циклу это длина подстроки
	for i := 0; i < len(s1); i++ {
		s1Count[s1[i]-'a']++
		s2Count[s2[i]-'a']++
	}

	// Создаем переменную, в которой будет хранится количество совпадений
	// То есть если s1Count[i] == s2Count[i], тогда инкрементим matches++
	matches := 0

	// Сразу проверяем оба массива на совпадения
	for i := 0; i < 26; i++ {
		if s1Count[i] == s2Count[i] {
			matches++
		}
	}

	// Переходим к поиску по строке S2, используя sliding window,
	// для этого определим левый укзатель l =0
	l := 0

	// правый указатель у нас будет r, то есть это номер итерации цикла
	// цикл будет начинатся с len(s1), так как мы уже в массив добавили первый 3 значения
	for r := len(s1); r < len(s2); r++ {
		//первым делом проверяем, если matches = 26, то есть s1Count полностью совпадает s2Count, возвращаем true
		if matches == 26 {
			return true
		}

		// Находим значение индекса в срезе
		index := s2[r] - 'a'
		// И на срезе s2Count по этому индексу увеличиваем значение на 1
		s2Count[index]++

		// После того, как увеличили значение по новому индексу, мы проверим, может теперь у нас совпадают символы
		// сравниваем значение по новому индексу в первом (s1Count) и втором срезе (s2Count)
		// если значения равны, значит у нас появилось еще одно совпадение. То есть буква есть в обоих срезах.

		if s1Count[index] == s2Count[index] {
			matches++

			// но возможно, что увеличив это значение, вместо того, чтобы сделать его таким же как и в другом срезе
			// мы сделали его больше чем нужно,то есть теперь у нас появилось еще одно несоответствие с срезом s1Count
			// так как, если у нас не встречалось в строке символов мы их отмечали как 0, то теперь, во втором срезе s2Count
			// появилась единица под новым индексом или же, если повторился символ, то увеличился больше, чем нужно
			// например, если в s1count по нулевому индексу была 1 (означает букву "a"), а при итерации по второй строке
			// у нас появилась еще одна "a", то у нас бы во втором срезе под нулевым индексом теперь была ба не 1, а стала бы 2
			// То есть появилось несоответствие.
			// Теперь мы проверяем не стали ли индексы, который уже были равны, то есть совпадали,
			// различными, например под индексом 5, в обоих срезах были бы 0 0, в таком случае они совпадают
			// но когда мы проходились по строке у нас попался индекс 5, и мы увеличили его во втором срезе s2Count,
			// Теперь у нас в обоих срезах будет вот так 0 1, и поэтому мы делаем проверку, а именно
			// увеличиваем значение на 1 по индексу в первом срезе и если он равен значение по индексу во втором срезе,
			// это значит, что у нас появилось еще одно несоответствие, и мы уменьшили matches

		} else if s1Count[index]+1 == s2Count[index] {
			matches--
		}

		// Теперь мы делаем то же самое, только теперь используя левый указатель,
		// так как мы перешли на следующую итерацию (r+1), то мы должны также сместить левый указатель (l+1)
		// и мы должны уменьшить значение по левому индексу для s2Count
		// сначала находим индекс используя значение левого указателя
		index = s2[l] - 'a'
		// Уменьшаем значение под этим индексом в срезе s2Count, так как эта буква уже не будет в промежутке l-r , например (0-2)
		s2Count[index]--
		// делаем проверку после уменьшения, если значение и в перовом s1Count срезе и во втором s2count равны
		// то есть они совпадаеют, то мы matches увеличиваем на 1
		if s1Count[index] == s2Count[index] {
			matches++
			// если уж так получилось, что мы понизили значение индекса, который есть в s1Count
			// то есть мы проверили что если под этим индексом понизить значение в первом срезе и он будет равен значению второму
			// в таком случае у нас появилось еще одно несовпадение и мы matches уменьшаем
		} else if s1Count[index]-1 == s2Count[index] {
			matches--
		}
		// и далее просто сдвивагем следующий указатель.
		l++
	}

	//проверяем, если совпадений не 26, значит есть лишние символы и подстрока s1 не существует в s2
	return matches == 26
}
