package main

func main() {

}

type Node struct {
	Val    int
	Next   *Node
	Random *Node
}

func copyRandomList(head *Node) *Node {
	// Создаем карту в которой будем хранить указатели на ноды, которые мы сами создадим,
	// но значения в них будут как в старых нодах, также мы здесь сразу определили такой вариант по ключу nil
	// так как в исходном списке поле Random может указывать на nil, и чтобы не было ошибки мы заранее добавили такой вариант
	oldToCopy := map[*Node]*Node{nil: nil}

	// Определяем переменную curr которая является указателем на голову списка
	curr := head
	// Проходимся по связному списку пока текущий нод не будет равен nil
	for curr != nil {
		// создаем новый нод, и в поле значения (Val) присваиваем значение текущего узла curr.Val
		// Таким образом мы создали новый нод и скопировали туда значение из старого нода
		newNode := &Node{Val: curr.Val}
		// Добавляем в нашу карту новый нод, который будет хранится по ключу curr
		// Это позволяет сохранить соответствие между старым (исходным) узлом и его копией.
		oldToCopy[curr] = newNode
		// Двигаемся дальше по списку
		curr = curr.Next
	}

	// Теперь у нас в мапе соотнесены старые ноды с новыми, точнее их копиями

	// Опять переопределяем curr, также будет являться указателем на голову списка
	curr = head
	// Делаем еще один проход по связному списку
	for curr != nil {
		// Теперь в переменную copy присваиваем копию текущего узла, то есть, у нас в мапе сейчас
		// соотнесены старые ноды с новыми. То есть ключ это исходная нода, а значение это ее копия.
		// И по сути, по ключу определенному мы достаем копию этого узла
		copy := oldToCopy[curr]
		// Теперь определяем для этого копии следующие поля, а именно указатель на следующий узел и указатель на случайный узел
		// Следующий узел также представляет из себя копию, поэтому достаем его по ключу curr.Next, так как у нас соотнесены исходные узлы и их копии
		copy.Next = oldToCopy[curr.Next]
		// Также определяем случайный узел, поэтому достаем его по ключу curr.Random
		// Мы для этого также обращаемся к мапе, так как у нас там есть все существующие ноды и мы можем достать копию рандомной ноды
		copy.Random = oldToCopy[curr.Random]
		// Также двигаемся по списку
		curr = curr.Next
	}

	// Делаем возврат копии головного узла, который находится в мапе по ключу head
	return oldToCopy[head]
}
