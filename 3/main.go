package main

import "fmt"

func main() {
	fmt.Println(lengthOfLongestSubstring("bbbbb"))
}

// Найти самую длинную неповторяющуюся подстроку. Все символы разные
func lengthOfLongestSubstring(s string) int {
	// Определяем результирующую переменную
	res := 0
	// Определяем левый указатель. Это индекс начала нашей подстроки
	left := 0
	// Создаем карту, в которой будем отмечать, встречался уже определенный символ или нет
	mp := make(map[rune]bool)
	// Проходимся циклом по строке
	for i, v := range s {
		// Если у нас встретился символ который уже есть в мапе, то мы должны двигать левый указатель, то есть мы сокращаем нашу подстроку
		// и должны удалять символ из мапы под индексом left, пока это новое значение (v) из строки (s) еще находится в мапе
		// Так как мы не можем просто удалить этот элемент (v) из мапы, если до него были другие элементы, потому что это уже будет не подстрока

		// Например есть строка "pwwk", мы проходимся по ней, добавляем в мапу сначала 'p',
		// потом 'w', но на следующем этапе у нас появилась опять 'w', то есть она повторилась
		// и в таком случае мы не можем просто удалить 'w',
		// так как перед ней был еще другой символ, а подстрока это последовательность символов строки
		// поэтому , чтобы удалить 'w', мы должны удалить и 'p', сместив при этом левый указатель,
		// который указывает начало подстроки.
		// Грубо говоря, мы можем посмотреть на индексы, и для корректной подстроки
		// они должны идти последовательно [1,2,3], не может быть подстроки с индексами [1,3]

		for mp[v] {
			delete(mp, rune(s[left]))
			left++
		}
		// Отмечаем в мапе по ключу v (то есть буква), что такой символ уже есть.
		mp[v] = true
		// Проверяем длину подстроки, если она больше чем res, то перезаписываем
		if i-left+1 > res {
			res = i - left + 1
		}
	}
	// Возвращаем результат
	return res
}
